#include "analog.h"

#include "stm32f10x_conf.h"
#include "stm32f10x.h"

#include "comunication.h"
#include "stm32f10x_it.h"


uint16_t ADCValue[5];

void BLControlInit(void)
{
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_OCInitTypeDef TIM_OCInitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	//gpio initial
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//??????50MHz
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//??????
	GPIO_Init(GPIOA, &GPIO_InitStructure);//?????GPIOx???

	//clock initial
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);//??????APB1????
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//??????APB2????
	
	//timer2 initial
	TIM_TimeBaseStructure.TIM_Prescaler = 100;//????
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;//??????
	TIM_TimeBaseStructure.TIM_Period = 10000;//?????????????????????????
	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;//TDTS = Tck_tim
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0x01;//?????
	TIM_TimeBaseInit(TIM2,&TIM_TimeBaseStructure);//???

	//timer2 channel 2initial
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//PWM??1
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//??
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;//??
	TIM_OCInitStructure.TIM_Pulse = 10000;//????,????????
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;//?????
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;//?????
	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;//???
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;//???
	TIM_OC2Init(TIM2,&TIM_OCInitStructure);//???
  TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);//?????TIM?????????CCR1

	TIM_ARRPreloadConfig(TIM2, ENABLE);//??????TIMx?ARR????????

	TIM_Cmd(TIM2, ENABLE);//??????TIMx??
	
}

void SetBL(uint16_t BL)
{
	TIM_SetCompare2(TIM2, BL);
}

uint16_t GetADCValue(uint8_t channel)
{
	switch(channel)
	{
		case 0:	ADC_RegularChannelConfig(ADC1,ADC_Channel_10, 1, ADC_SampleTime_1Cycles5); break;//????ADC??????,??????????????
		case 1:	ADC_RegularChannelConfig(ADC1,ADC_Channel_11, 1, ADC_SampleTime_1Cycles5); break;//????ADC??????,??????????????
		case 2:	ADC_RegularChannelConfig(ADC1,ADC_Channel_12, 1, ADC_SampleTime_1Cycles5); break;//????ADC??????,??????????????
		case 3:	ADC_RegularChannelConfig(ADC1,ADC_Channel_13, 1, ADC_SampleTime_1Cycles5); break;//????ADC??????,??????????????
		case 4:	ADC_RegularChannelConfig(ADC1,ADC_Channel_14, 1, ADC_SampleTime_1Cycles5); break;//????ADC??????,??????????????
		case 5: ADC_RegularChannelConfig(ADC1,ADC_Channel_15, 1, ADC_SampleTime_1Cycles5); break;//????ADC??????,??????????????
		case 6: ADC_RegularChannelConfig(ADC1,ADC_Channel_16, 1, ADC_SampleTime_239Cycles5); break;//????ADC??????,??????????????

  }
	
	ADC_SoftwareStartConvCmd(ADC1,ENABLE);//?????????ADC?????????
	while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==0);
	return ADC_GetConversionValue(ADC1);	
}

void ADCInit(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;	
	ADC_InitTypeDef ADC_InitStructure;

	//clock initial
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);//??????APB2????
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);//??????APB2????

	
	//GPIO Initial
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;//??????10MHz
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;//????
	GPIO_Init(GPIOC, &GPIO_InitStructure);//?????GPIOx???
	
	//ADC mode initial
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;//????
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;//????(???)
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;//????
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//??????????????
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC?????
	ADC_InitStructure.ADC_NbrOfChannel = 1;//?????ADC?????,?????1-16
	ADC_Init(ADC1,&ADC_InitStructure);//?????
	
	//ADC clock initial
	RCC_ADCCLKConfig(RCC_PCLK2_Div8);//??ADC??(ADCCLK)
	
  //
	ADC_RegularChannelConfig(ADC1,ADC_Channel_13, 1, ADC_SampleTime_239Cycles5);//????ADC??????,??????????????
  
	//enable temperature
	ADC_TempSensorVrefintCmd(ENABLE);//????????????????????
	
  //enable ADC
	ADC_Cmd(ADC1,ENABLE);//?????????ADC

	//ADC Calibration
	ADC_ResetCalibration(ADC1);//?????ADC??????
  while(ADC_GetResetCalibrationStatus(ADC1));//??ADC??????????
  ADC_StartCalibration(ADC1);//????ADC?????
  while(ADC_GetCalibrationStatus(ADC1));//????ADC?????
	
	
}

void ADCInterrupt(void)
{
	static uint8_t channel=0;
	if(TimeTicket%10==3)
	{
		//USARTSendString("channel:");
		//USARTSendFigDec(channel,1);
		//USARTSendString("adc value:");
		if(channel!=4)
		{
			ADCValue[channel]=GetADCValue(channel);
	  	//USARTSendFigDec(ADCValue[channel]*4/5,4);
			channel++;
		}
		else
		{
			ADCValue[4]=GetADCValue(6);
	  	//USARTSendFigDec(ADCValue[channel]*4/5,4);
			channel=0;
		}
		
	}
}


